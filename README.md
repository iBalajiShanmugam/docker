# Docker: A Comprehensive Guide

## Table of Contents
1. [Introduction to Docker](#introduction-to-docker)
2. [Docker Architecture](#docker-architecture)
3. [Installation](#installation)
4. [Docker Basics](#docker-basics)
5. [Working with Docker Images](#working-with-docker-images)
6. [Working with Docker Containers](#working-with-docker-containers)
7. [Docker Networking](#docker-networking)
8. [Docker Volumes and Data Persistence](#docker-volumes-and-data-persistence)
9. [Creating Docker Images with Dockerfiles](#creating-docker-images-with-dockerfiles)
10. [Docker Compose](#docker-compose)
11. [Docker in Production](#docker-in-production)
12. [Best Practices](#best-practices)
13. [Teaching Docker](#teaching-docker)
14. [Practical Exercises](#practical-exercises)
15. [Resources](#resources)

## Introduction to Docker

### What is Docker?

Docker is an open-source platform that automates the deployment, scaling, and management of applications using containerization technology. Docker packages applications and their dependencies together in the form of containers, ensuring that an application works seamlessly in any environment.

### Why Docker?

Docker solves the "it works on my machine" problem by creating consistent environments across different stages of development. Here's why Docker has become so popular:

- **Consistency**: Applications run the same way regardless of where Docker is installed.
- **Isolation**: Applications and their dependencies are isolated from each other.
- **Portability**: Containers can run on any system that has Docker installed.
- **Efficiency**: Docker containers share the host system's kernel and are lightweight compared to virtual machines.
- **Scalability**: Easy to scale applications up or down by adding or removing containers.
- **Version Control**: Docker images can be versioned, making it easy to roll back to a previous version if needed.

### Containers vs. Virtual Machines

Understanding the difference between containers and virtual machines (VMs) is essential:

**Virtual Machines**:
- Include a full copy of an operating system
- Slow to boot
- Resource-intensive
- Complete isolation

**Containers**:
- Share the host's kernel
- Start almost instantly
- Use fewer resources
- Lightweight isolation

![Containers vs VMs](https://docs.docker.com/images/Container%402x.png)

## Docker Architecture

Docker uses a client-server architecture with several main components:

### Docker Client

The Docker client (`docker`) is the primary way users interact with Docker. When you run commands like `docker run`, the client sends these commands to the Docker daemon.

### Docker Daemon (Server)

The Docker daemon (`dockerd`) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. A daemon can also communicate with other daemons.

### Docker Registry

A Docker registry stores Docker images. Docker Hub is a public registry that anyone can use, and Docker is configured to look for images on Docker Hub by default. You can also set up private registries.

### Docker Objects

**Images**: A read-only template with instructions for creating a Docker container.

**Containers**: A runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI.

**Networks**: Facilitate communication between Docker containers and the outside world.

**Volumes**: Persist data generated by and used by Docker containers.

## Installation

### Windows

1. Download Docker Desktop for Windows from the [official website](https://www.docker.com/products/docker-desktop).
2. Double-click the installer to run it.
3. Follow the installation instructions.
4. Start Docker Desktop from the Windows Start menu.

### macOS

1. Download Docker Desktop for Mac from the [official website](https://www.docker.com/products/docker-desktop).
2. Double-click the DMG file and drag the Docker icon to the Applications folder.
3. Open Docker from the Applications folder.
4. Follow the on-screen instructions to complete the installation.

### Linux (Ubuntu)

```bash
# Update the apt package index
sudo apt-get update

# Install packages to allow apt to use a repository over HTTPS
sudo apt-get install -y \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common

# Add Docker's official GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

# Set up the stable repository
sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"

# Update the apt package index again
sudo apt-get update

# Install the latest version of Docker Engine and containerd
sudo apt-get install -y docker-ce docker-ce-cli containerd.io

# Verify that Docker Engine is installed correctly
sudo docker run hello-world
```

### Verifying Installation

To verify that Docker is installed correctly, run the following command:

```bash
docker --version
docker run hello-world
```

## Docker Basics

### Docker Command Line Structure

Docker commands follow a general syntax:
```
docker [OPTIONS] COMMAND [ARG...]
```

Common commands include:
- `docker pull`: Download an image from a registry
- `docker run`: Create and start a container
- `docker ps`: List running containers
- `docker images`: List images
- `docker stop`: Stop a running container
- `docker rm`: Remove a container
- `docker rmi`: Remove an image

### First Docker Command

Let's start with the classic "Hello World" example:

```bash
docker run hello-world
```

This command does the following:
1. Checks if the `hello-world` image exists locally
2. If not, downloads it from Docker Hub
3. Creates a container from the image
4. Runs the container, which prints a hello message
5. Exits when the container's process completes

### Getting Help

Docker has built-in help for all commands:

```bash
docker --help
docker run --help
```

## Working with Docker Images

Images are the blueprints for containers. They are read-only templates used to create containers.

### Finding Images

Search for images on Docker Hub:

```bash
docker search nginx
```

### Pulling Images

Download an image from Docker Hub:

```bash
docker pull ubuntu:latest
```

The tag (`:latest`) specifies which version of the image to pull. If not specified, Docker defaults to `latest`.

### Listing Images

View all locally downloaded images:

```bash
docker images
```

Or the newer command:

```bash
docker image ls
```

### Image Details

Inspect an image to see detailed information:

```bash
docker image inspect ubuntu
```

### Removing Images

Remove an image:

```bash
docker rmi ubuntu
# or
docker image rm ubuntu
```

Force removal:

```bash
docker rmi -f ubuntu
```

Remove all unused images:

```bash
docker image prune
```

## Working with Docker Containers

Containers are running instances of Docker images.

### Running Containers

Create and start a container:

```bash
docker run nginx
```

Run a container in detached mode (in the background):

```bash
docker run -d nginx
```

Run a container with a specific name:

```bash
docker run --name my-nginx -d nginx
```

Run a container with port mapping (maps host port 8080 to container port 80):

```bash
docker run -p 8080:80 -d nginx
```

Run a container interactively with a terminal:

```bash
docker run -it ubuntu bash
```

### Listing Containers

List running containers:

```bash
docker ps
```

List all containers (including stopped ones):

```bash
docker ps -a
```

Or using the newer commands:

```bash
docker container ls
docker container ls -a
```

### Container Management

Stop a running container:

```bash
docker stop container_id
```

Start a stopped container:

```bash
docker start container_id
```

Restart a container:

```bash
docker restart container_id
```

Pause a container's processes:

```bash
docker pause container_id
```

Unpause a container:

```bash
docker unpause container_id
```

### Removing Containers

Remove a stopped container:

```bash
docker rm container_id
```

Force remove a running container:

```bash
docker rm -f container_id
```

Remove all stopped containers:

```bash
docker container prune
```

### Container Logs and Information

View container logs:

```bash
docker logs container_id
```

Follow log output in real-time:

```bash
docker logs -f container_id
```

Show detailed information about a container:

```bash
docker inspect container_id
```

Show container resource usage statistics:

```bash
docker stats container_id
```

### Executing Commands in Containers

Run a command in a running container:

```bash
docker exec container_id ls -la
```

Access a running container's shell:

```bash
docker exec -it container_id bash
```

## Docker Networking

Docker networking allows containers to communicate with each other and with the outside world.

### Network Types

Docker comes with several network drivers:
- **bridge**: The default network driver. Used when applications run in standalone containers.
- **host**: Removes network isolation between the container and the host.
- **none**: Disables all networking for the container.
- **overlay**: Connects multiple Docker daemons together and enables swarm services to communicate.
- **macvlan**: Allows you to assign a MAC address to a container, making it appear as a physical device on your network.
- **ipvlan**: Similar to macvlan but uses IP addresses instead of MAC addresses.

### Listing Networks

View all networks:

```bash
docker network ls
```

### Creating Networks

Create a new network:

```bash
docker network create my-network
```

### Connecting Containers to Networks

Connect a container to a network at run time:

```bash
docker run --network=my-network -d nginx
```

Connect an existing container to a network:

```bash
docker network connect my-network container_id
```

### Container Communication

Containers on the same network can communicate using their container names as hostnames.

Example: If you have two containers named `web` and `db` on the same network, the `web` container can connect to the `db` container simply by using `db` as the hostname.

### Disconnecting and Removing Networks

Disconnect a container from a network:

```bash
docker network disconnect my-network container_id
```

Remove a network:

```bash
docker network rm my-network
```

## Docker Volumes and Data Persistence

Volumes provide persistent storage for containers, ensuring data is preserved even when containers are destroyed.

### Types of Data Storage in Docker

1. **Volumes**: Managed by Docker in `/var/lib/docker/volumes/` on the host. Best for persistent data.
2. **Bind Mounts**: Map a host directory or file to a container directory or file.
3. **tmpfs Mounts**: Stored in the host's memory only. Temporary, non-persistent.

### Creating and Managing Volumes

Create a volume:

```bash
docker volume create my-volume
```

List volumes:

```bash
docker volume ls
```

Inspect a volume:

```bash
docker volume inspect my-volume
```

Remove a volume:

```bash
docker volume rm my-volume
```

Remove all unused volumes:

```bash
docker volume prune
```

### Using Volumes with Containers

Run a container with a volume:

```bash
docker run -v my-volume:/path/in/container -d nginx
```

Using a bind mount:

```bash
docker run -v /host/path:/container/path -d nginx
```

Or with the newer syntax:

```bash
docker run --mount source=my-volume,target=/path/in/container -d nginx
```

### Sharing Data Between Containers

Multiple containers can use the same volume for shared access to data.

```bash
docker run -v my-volume:/data --name container1 -d ubuntu
docker run -v my-volume:/data --name container2 -d ubuntu
```

### Backup and Restore Volume Data

Backup a volume:

```bash
docker run --rm -v my-volume:/source -v $(pwd):/backup ubuntu tar -czvf /backup/my-volume-backup.tar.gz -C /source .
```

Restore a volume:

```bash
docker run --rm -v my-volume:/target -v $(pwd):/backup ubuntu bash -c "cd /target && tar -xzvf /backup/my-volume-backup.tar.gz"
```

## Creating Docker Images with Dockerfiles

A Dockerfile is a text document containing instructions to build a Docker image.

### Dockerfile Basics

Create a file named `Dockerfile` (no extension) with the following structure:

```Dockerfile
# Use an official base image
FROM ubuntu:latest

# Set metadata
LABEL maintainer="your-email@example.com"
LABEL version="1.0"

# Set environment variables
ENV NODE_ENV=production

# Set the working directory
WORKDIR /app

# Copy files from host to container
COPY . .

# Run commands to install dependencies
RUN apt-get update && \
    apt-get install -y nodejs npm && \
    apt-get clean

# Expose ports
EXPOSE 3000

# Command to run when the container starts
CMD ["npm", "start"]
```

### Building an Image

Build an image from a Dockerfile:

```bash
docker build -t my-image .
```

Build with a tag:

```bash
docker build -t my-image:1.0 .
```

### Dockerfile Instructions

- **FROM**: Sets the base image
- **LABEL**: Adds metadata to an image
- **ENV**: Sets environment variables
- **WORKDIR**: Sets the working directory
- **COPY/ADD**: Copies files from host to container
- **RUN**: Executes commands in a new layer
- **EXPOSE**: Documents which ports the container listens on
- **CMD**: Provides default command for executing a container
- **ENTRYPOINT**: Configures a container to run as an executable

### Multi-Stage Builds

Multi-stage builds allow you to use multiple FROM statements in a Dockerfile. Each FROM instruction begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don't need in the final image.

```Dockerfile
# Build stage
FROM node:14 AS build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

This example uses Node.js to build an application and then copies only the build artifacts to a smaller Nginx image for production.

### Best Practices for Dockerfiles

- Use specific base image tags, not `latest`
- Combine related commands with `&&` to reduce layers
- Remove unneeded files after installations
- Use `.dockerignore` to exclude unnecessary files
- Sort multi-line arguments alphanumerically
- Use multi-stage builds to create smaller images

## Docker Compose

Docker Compose is a tool for defining and running multi-container Docker applications.

### Docker Compose Basics

Create a file named `docker-compose.yml`:

```yaml
version: '3'
services:
  web:
    build: ./web
    ports:
      - "5000:5000"
    volumes:
      - ./web:/code
    depends_on:
      - redis
  redis:
    image: redis
```

### Key Docker Compose Commands

Start services:

```bash
docker-compose up
```

Start in detached mode:

```bash
docker-compose up -d
```

Stop services:

```bash
docker-compose down
```

Stop and remove volumes:

```bash
docker-compose down -v
```

View logs:

```bash
docker-compose logs
```

Scale services:

```bash
docker-compose up -d --scale web=3
```

### Docker Compose File Structure

- **version**: Compose file format version
- **services**: Containers to launch
- **volumes**: Volume definitions
- **networks**: Network definitions
- **configs**: Configuration definitions
- **secrets**: Secret definitions

### Example: Web Application with Database

```yaml
version: '3'
services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgres://postgres:postgres@db:5432/mydb
    depends_on:
      - db
  db:
    image: postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: mydb
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## Docker in Production

### Security Best Practices

1. **Use official images** from trusted sources.
2. **Scan images** for vulnerabilities using tools like Docker Scan or Trivy.
3. **Run containers as non-root** users.
4. **Use read-only file systems** when possible.
5. **Limit resources** using Docker's resource constraints.
6. **Use secrets management** for sensitive data.
7. **Keep Docker updated** to get the latest security patches.

### Container Orchestration

For production environments with multiple containers, consider container orchestration platforms:

- **Docker Swarm**: Built into Docker, simpler but less feature-rich.
- **Kubernetes**: Industry standard, more complex but highly scalable and powerful.
- **Amazon ECS/EKS**: AWS's container orchestration services.
- **Azure AKS**: Microsoft's managed Kubernetes service.
- **Google GKE**: Google's managed Kubernetes service.

### Monitoring and Logging

Tools for monitoring Docker containers:

- **Prometheus** and **Grafana**: For metrics collection and visualization.
- **ELK Stack** (Elasticsearch, Logstash, Kibana): For log management.
- **Fluentd**: For unified logging.
- **cAdvisor**: For container resource usage and performance analysis.
- **Portainer**: For container management and monitoring through a UI.

### CI/CD with Docker

Integrating Docker with Continuous Integration and Continuous Deployment:

1. **Build**: Create Docker images during CI builds.
2. **Test**: Run tests in containers.
3. **Push**: Push tested images to a registry.
4. **Deploy**: Update containers in production.

Examples of CI/CD tools compatible with Docker:
- GitLab CI
- Jenkins
- GitHub Actions
- CircleCI
- Travis CI

## Best Practices

### Efficiency

1. **Use alpine-based images** when possible for smaller footprints.
2. **Optimize Dockerfiles** to minimize layers.
3. **Use multi-stage builds** to reduce final image size.
4. **Clean up unnecessary files** in the same layer they're created.

### Maintainability

1. **Document your containers** with proper labels.
2. **Use meaningful tags** for your images.
3. **Keep base images updated** regularly.
4. **Use docker-compose for complex applications** to make configurations more manageable.

### Stability

1. **Pin specific versions** of base images and dependencies.
2. **Implement health checks** to ensure containers are functioning correctly.
3. **Set resource limits** to prevent containers from consuming too many resources.
4. **Use restart policies** to automatically restart failed containers.

### Example: Adding health checks

```Dockerfile
FROM nginx:alpine
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
```

In docker-compose.yml:

```yaml
services:
  web:
    image: nginx:alpine
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 3s
      retries: 3
```

## Teaching Docker

### Classroom Setup

1. **Ensure all students have Docker installed** before the class begins.
2. **Prepare a Docker Hub account** for sharing images.
3. **Consider using Docker Playground** (https://labs.play-with-docker.com/) for browser-based learning.
4. **Create a GitHub repository** with all necessary files for exercises.

### Teaching Strategies

1. **Start with the conceptual understanding** of containers before diving into commands.
2. **Use visual aids** to explain Docker architecture and concepts.
3. **Demonstrate live examples** and encourage students to follow along.
4. **Progress from simple to complex** - start with single containers, then move to multi-container applications.
5. **Incorporate hands-on exercises** after each concept.
6. **Use real-world examples** relevant to your students' field.
7. **Allocate time for troubleshooting** common issues.

### Common Student Challenges

1. **Permission issues**: Especially on Linux systems.
2. **Understanding networking**: Explaining how containers communicate.
3. **Volume concepts**: The difference between bind mounts and volumes.
4. **dockerfile syntax errors**: Debugging Dockerfile issues.
5. **Resource constraints**: Containers using too much memory or CPU.

## Practical Exercises

### Exercise 1: Hello World

**Objective**: Run your first container and understand basic commands.

**Tasks**:
1. Pull the hello-world image
2. Run the hello-world container
3. View the list of all containers
4. Remove the container

### Exercise 2: Working with Nginx

**Objective**: Run a web server and understand port mapping.

**Tasks**:
1. Pull the Nginx image
2. Run Nginx and map port 8080 to container port 80
3. Visit http://localhost:8080 in a browser
4. View Nginx logs
5. Stop and remove the container

### Exercise 3: Creating a Custom Image

**Objective**: Create a custom Docker image using a Dockerfile.

**Tasks**:
1. Create a simple HTML file
2. Create a Dockerfile that uses Nginx and copies your HTML file
3. Build the Docker image
4. Run a container from your image
5. Verify your HTML is being served

### Exercise 4: Multi-Container Application

**Objective**: Create a multi-container application using Docker Compose.

**Tasks**:
1. Create a simple web application that connects to a database
2. Write a docker-compose.yml file defining both services
3. Build and run the application using Docker Compose
4. Verify the application works correctly
5. Make a change to the application and rebuild

### Exercise 5: Volume Management

**Objective**: Understand data persistence using volumes.

**Tasks**:
1. Create a Docker volume
2. Run a container that uses the volume
3. Create and modify files in the container
4. Stop and remove the container
5. Create a new container using the same volume
6. Verify that data persists

## Resources

### Official Documentation
- [Docker Documentation](https://docs.docker.com/)
- [Docker Hub](https://hub.docker.com/)
- [Docker Compose Documentation](https://docs.docker.com/compose/)

### Books
- "Docker Deep Dive" by Nigel Poulton
- "Docker in Action" by Jeff Nickoloff
- "Docker: Up & Running" by Sean P. Kane and Karl Matthias

### Online Courses
- Docker's Official Training: https://training.docker.com/
- Docker for Beginners on Udemy
- Docker Mastery on Udemy by Bret Fisher

### Community Resources
- Docker Community Forums: https://forums.docker.com/
- Stack Overflow Docker Tag: https://stackoverflow.com/questions/tagged/docker
- Docker Reddit Community: https://www.reddit.com/r/docker/

### Cheat Sheets
- [Docker Cheat Sheet](https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf)
- [Docker Compose Cheat Sheet](https://devhints.io/docker-compose)

---

This guide provides a comprehensive overview of Docker, from basic concepts to advanced techniques. As you become more familiar with Docker, you'll discover even more powerful ways to use containers in your development and deployment workflows.